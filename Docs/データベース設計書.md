# BabySteps アプリ データベース設計書

## 1. 概要

### 1.1 使用技術
- **データベース**: SwiftData
- **プラットフォーム**: iOS 17.0+
- **アーキテクチャ**: MVVM + SwiftData

### 1.2 設計方針
- ローカル完結のデータ管理
- シンプルで拡張しやすい構造
- パフォーマンスを重視した設計

## 2. エンティティ設計

### 2.1 Task（タスク）

```swift
@Model
class Task {
    // MARK: - 基本情報
    @Attribute(.unique) var id: UUID
    var name: String
    var taskDescription: String?
    var category: TaskCategory
    var priority: Priority
    var targetAttempts: Int?
    
    // MARK: - 状態管理
    var isCompleted: Bool
    var isArchived: Bool
    
    // MARK: - 日時情報
    var createdAt: Date
    var updatedAt: Date
    var completedAt: Date?
    
    // MARK: - 統計情報
    var totalAttempts: Int
    var lastAttemptAt: Date?
    
    // MARK: - リレーション
    @Relationship(deleteRule: .cascade) var attempts: [Attempt]
    
    // MARK: - 初期化
    init(name: String, category: TaskCategory, priority: Priority = .medium) {
        self.id = UUID()
        self.name = name
        self.category = category
        self.priority = priority
        self.isCompleted = false
        self.isArchived = false
        self.createdAt = Date()
        self.updatedAt = Date()
        self.totalAttempts = 0
    }
}
```

### 2.2 Attempt（着手記録）

```swift
@Model
class Attempt {
    // MARK: - 基本情報
    @Attribute(.unique) var id: UUID
    var timestamp: Date
    var note: String?
    
    // MARK: - リレーション
    var task: Task?
    
    // MARK: - 初期化
    init(task: Task, note: String? = nil) {
        self.id = UUID()
        self.timestamp = Date()
        self.note = note
        self.task = task
    }
}
```

### 2.3 TaskCategory（タスクカテゴリ）

```swift
enum TaskCategory: String, CaseIterable, Codable {
    case habit = "habit"
    case project = "project"
    case learning = "learning"
    case other = "other"
    
    var displayName: String {
        switch self {
        case .habit: return "習慣"
        case .project: return "プロジェクト"
        case .learning: return "学習"
        case .other: return "その他"
        }
    }
    
    var icon: String {
        switch self {
        case .habit: return "repeat"
        case .project: return "folder"
        case .learning: return "book"
        case .other: return "ellipsis"
        }
    }
    
    var color: Color {
        switch self {
        case .habit: return .orange
        case .project: return .blue
        case .learning: return .green
        case .other: return .gray
        }
    }
}
```

### 2.4 Priority（優先度）

```swift
enum Priority: String, CaseIterable, Codable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    
    var displayName: String {
        switch self {
        case .low: return "低"
        case .medium: return "中"
        case .high: return "高"
        }
    }
    
    var icon: String {
        switch self {
        case .low: return "arrow.down.circle"
        case .medium: return "minus.circle"
        case .high: return "exclamationmark.circle"
        }
    }
    
    var color: Color {
        switch self {
        case .low: return .green
        case .medium: return .yellow
        case .high: return .red
        }
    }
}
```

## 3. データベーススキーマ

### 3.1 スキーマ定義

```swift
@Model
class BabyStepsSchema {
    static let schema = Schema([
        Task.self,
        Attempt.self
    ])
    
    static let modelContainer: ModelContainer = {
        let schema = Schema([
            Task.self,
            Attempt.self
        ])
        
        let modelConfiguration = ModelConfiguration(
            schema: schema,
            isStoredInMemoryOnly: false
        )
        
        do {
            return try ModelContainer(
                for: schema,
                configurations: [modelConfiguration]
            )
        } catch {
            fatalError("Could not create ModelContainer: \(error)")
        }
    }()
}
```

### 3.2 マイグレーション対応

```swift
enum SchemaV1: VersionedSchema {
    static var versionIdentifier = Schema.Version(1, 0, 0)
    
    static var models: [any PersistentModel.Type] {
        [Task.self, Attempt.self]
    }
}

enum SchemaV2: VersionedSchema {
    static var versionIdentifier = Schema.Version(2, 0, 0)
    
    static var models: [any PersistentModel.Type] {
        [Task.self, Attempt.self]
    }
    
    @Model
    class Task {
        // V2で追加されるフィールド
        var isArchived: Bool
        var tags: [String]
    }
}
```

## 4. データアクセス層

### 4.1 TaskRepository

```swift
class TaskRepository: ObservableObject {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    // MARK: - タスク作成
    func createTask(name: String, category: TaskCategory, priority: Priority = .medium) throws -> Task {
        let task = Task(name: name, category: category, priority: priority)
        modelContext.insert(task)
        try modelContext.save()
        return task
    }
    
    // MARK: - タスク取得
    func fetchActiveTasks() throws -> [Task] {
        let descriptor = FetchDescriptor<Task>(
            predicate: #Predicate<Task> { task in
                !task.isCompleted && !task.isArchived
            },
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        return try modelContext.fetch(descriptor)
    }
    
    func fetchCompletedTasks() throws -> [Task] {
        let descriptor = FetchDescriptor<Task>(
            predicate: #Predicate<Task> { task in
                task.isCompleted
            },
            sortBy: [SortDescriptor(\.completedAt, order: .reverse)]
        )
        return try modelContext.fetch(descriptor)
    }
    
    func fetchTasksByCategory(_ category: TaskCategory) throws -> [Task] {
        let descriptor = FetchDescriptor<Task>(
            predicate: #Predicate<Task> { task in
                task.category == category && !task.isCompleted
            },
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        return try modelContext.fetch(descriptor)
    }
    
    // MARK: - タスク更新
    func updateTask(_ task: Task) throws {
        task.updatedAt = Date()
        try modelContext.save()
    }
    
    func completeTask(_ task: Task) throws {
        task.isCompleted = true
        task.completedAt = Date()
        task.updatedAt = Date()
        try modelContext.save()
    }
    
    func archiveTask(_ task: Task) throws {
        task.isArchived = true
        task.updatedAt = Date()
        try modelContext.save()
    }
    
    // MARK: - タスク削除
    func deleteTask(_ task: Task) throws {
        modelContext.delete(task)
        try modelContext.save()
    }
}
```

### 4.2 AttemptRepository

```swift
class AttemptRepository: ObservableObject {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    // MARK: - 着手記録作成
    func recordAttempt(for task: Task, note: String? = nil) throws -> Attempt {
        let attempt = Attempt(task: task, note: note)
        modelContext.insert(attempt)
        
        // タスクの統計情報を更新
        task.totalAttempts += 1
        task.lastAttemptAt = Date()
        task.updatedAt = Date()
        
        try modelContext.save()
        return attempt
    }
    
    // MARK: - 着手記録取得
    func fetchAttempts(for task: Task, limit: Int = 10) throws -> [Attempt] {
        let descriptor = FetchDescriptor<Attempt>(
            predicate: #Predicate<Attempt> { attempt in
                attempt.task?.id == task.id
            },
            sortBy: [SortDescriptor(\.timestamp, order: .reverse)]
        )
        descriptor.fetchLimit = limit
        return try modelContext.fetch(descriptor)
    }
    
    func fetchAttemptsInDateRange(from: Date, to: Date) throws -> [Attempt] {
        let descriptor = FetchDescriptor<Attempt>(
            predicate: #Predicate<Attempt> { attempt in
                attempt.timestamp >= from && attempt.timestamp <= to
            },
            sortBy: [SortDescriptor(\.timestamp, order: .descending)]
        )
        return try modelContext.fetch(descriptor)
    }
    
    // MARK: - 統計情報取得
    func getTotalAttempts(for task: Task) -> Int {
        return task.totalAttempts
    }
    
    func getAttemptsToday() throws -> Int {
        let today = Calendar.current.startOfDay(for: Date())
        let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today)!
        
        let attempts = try fetchAttemptsInDateRange(from: today, to: tomorrow)
        return attempts.count
    }
    
    func getStreakDays(for task: Task) throws -> Int {
        let attempts = try fetchAttempts(for: task, limit: 100)
        var streak = 0
        var currentDate = Date()
        
        for attempt in attempts {
            let attemptDate = Calendar.current.startOfDay(for: attempt.timestamp)
            let currentDateStart = Calendar.current.startOfDay(for: currentDate)
            
            if Calendar.current.isDate(attemptDate, inSameDayAs: currentDateStart) {
                streak += 1
                currentDate = Calendar.current.date(byAdding: .day, value: -1, to: currentDate)!
            } else {
                break
            }
        }
        
        return streak
    }
}
```

## 5. データ整合性

### 5.1 制約事項
- タスク名は必須（空文字列不可）
- 着手回数は0以上の整数
- 完了日時は完了状態の時のみ設定可能
- 削除されたタスクに関連する着手記録も削除

### 5.2 バリデーション
```swift
extension Task {
    var isValid: Bool {
        !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        totalAttempts >= 0 &&
        (targetAttempts == nil || targetAttempts! > 0)
    }
    
    var canComplete: Bool {
        !isCompleted && !isArchived
    }
    
    var canArchive: Bool {
        !isArchived
    }
}
```

## 6. パフォーマンス最適化

### 6.1 インデックス設定
```swift
@Model
class Task {
    // 検索頻度の高いフィールドにインデックスを設定
    @Attribute(.indexed) var category: TaskCategory
    @Attribute(.indexed) var isCompleted: Bool
    @Attribute(.indexed) var createdAt: Date
}

@Model
class Attempt {
    @Attribute(.indexed) var timestamp: Date
    @Attribute(.indexed) var taskId: UUID
}
```

### 6.2 クエリ最適化
- 必要なフィールドのみを取得
- 適切なfetchLimitの設定
- 複雑なクエリの回避

## 7. バックアップ・復元

### 7.1 データエクスポート
```swift
class DataExportService {
    func exportToCSV() -> String {
        // CSV形式でのデータ出力
    }
    
    func exportToJSON() -> Data {
        // JSON形式でのデータ出力
    }
}
```

### 7.2 データインポート
```swift
class DataImportService {
    func importFromJSON(_ data: Data) throws {
        // JSON形式からのデータインポート
    }
    
    func validateImportData(_ data: Data) -> Bool {
        // インポートデータの検証
    }
}
```

## 8. 将来の拡張性

### 8.1 iCloud同期対応
- CloudKitとの連携
- 競合解決の仕組み
- オフライン対応

### 8.2 通知機能
- ローカル通知の管理
- 通知履歴の保存

### 8.3 データ分析
- 高度な統計計算
- 機械学習による予測
- パフォーマンス分析